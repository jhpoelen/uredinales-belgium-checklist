---
title: "Darwin Core mapping"
subtitle: "For dataset: Checklist of the rust fungi of Belgium"
author: 
- Lien Reyserhove
- Peter Desmet
- Quentin Groom
date:"`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    theme: yeti
    df_print: paged
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

This document describes how we map the checklist data to Darwin Core.

# Setup

```{r, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r, eval = F}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # For data transformations

# None core tidyverse packages:
library(magrittr)  # For %<>% pipes

# Other packages
library(janitor)   # For cleaning input data
library(digest)    # Create hash function digests
library(readr)     # To read a delimited file into a tibble
library(rgbif)     # Interface to the GBIF API
library(stringi)   # For fast and convenient string manipulation
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/checklist-of-rusts.tsv"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"
dwc_distribution_file = "../data/processed/distribution.csv"
```

# Read data

Create a data frame `raw_data` from the source data:

```{r}
# Read the source data:
raw_data <- read_delim(raw_data_file, delim = "\t") 

# Clean the data somewhat: remove empty rows if present
raw_data %<>%
  remove_empty_rows()     # Remove empty rows
```

## Generate taxonID

To uniquely identify a taxon in the Taxon Core and reference taxa in the Extensions, we need a `taxonID`. Since we need it in all generated files, we generate it here in the raw data frame. It is a combination of `dataset-shortname:taxon:` and a hash based on the scientific name. As long as the scientific name doesn't change, the ID will be stable: 

```{r}
# Vectorize the digest function (The digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate(taxon_id = paste("uredinales-belgium", "taxon", vdigest(scientificName, algo="md5"), sep=":"))
```

Further processing:

```{r}
# Although most column names in `raw_data` have already been mapped to Darwin Core terms, some terms are missing. Additionally, not all terms belong to the same DwC Archive (Core or Extensions) and we want to clean and reorder the terms within one Archive. Therefore, we first add a prefix `raw_` to all column names in `raw_data`, we generate the DwC Archive files and we remove all `raw_` column names afterwards. 

# Add prefix `raw_` to all column names in `raw_data`:
colnames(raw_data) <- paste0("raw_", colnames(raw_data))

# Save those column names as a vector (makes it easier to remove them all later):
raw_colnames <- colnames(raw_data)
```

Preview data:

```{r}
head(raw_data)
```

# Create Taxon core

## Pre-processing

```{r}
taxon <- raw_data
```

### generic names

`raw_scientificName` includes information about the genus, specific epithet, infraspecific epithet, (bracket)authorship and taxonRank. The full scientific name will be mapped under `scientificName` in the Taxon Core. For enhanced readability, we parse `raw_scientificName` into its different components using the parsenames() function from [rgbif](https://cran.r-project.org/web/packages/rgbif/rgbif.pdf).

```{r}
parsed_names <- parsenames(taxon $ raw_scientificName)
```

Overview of the different compenents:

```{r}
head(parsed_names)
```

Select the columns needed for further mapping in the Taxon Core, i.e. `genusorabove`, `specificepithet`, `authorship`, `bracketauthorship`, `rankmarker` and `infraspecificepithet` (these will be mapped to, respectively, `genus`, `specificEpithet`, `scientificNameAuthorship`, `scientificNameAuthorship`, `taxonRank` and `infraspecificEpithet`). We also select `scientificname` as we need this to merge `parsed_names` with `scientificName` in the Taxon Core.

```{r}
parsed_names %<>% select(scientificname, genusorabove, specificepithet, authorship, bracketauthorship, rankmarker, infraspecificepithet)
```

`infraspecificepithet`, `authorship` and `bracketauthorship` contain NA's. We replace this by blanks:

```{r}
parsed_names %<>% replace_na(list(
  infraspecificepithet = "",
  authorship           = "",
  bracketauthorship    = ""))
```

Similar as for the raw data file, we add the prefix `pn_` to the column names of `parsed_names`. This is because we merge `parsed_names` to the Taxon Core and remove these columns after mapping to Darwin Core terms. 

```{r}
colnames(parsed_names) <- paste0("pn_", colnames(parsed_names))

# Save those column names as a vector (makes it easier to remove them all later):
pn_colnames <- colnames(parsed_names)
```

Amount of species in the Taxon Core before merge:

```{r, echo = F}
(before_merge <- nrow(taxon))
```

Merge `parsed_names` with the Taxon Core:

```{r}
taxon <- inner_join(taxon, parsed_names, by = c("raw_scientificName" = "pn_scientificname"))
```

Is the amount of species in the Taxon Core the same as before the merge?

```{r, echo = F}
before_merge == nrow(taxon)
```

## Term mapping
 
Map the source data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml):
 
### language

```{r}
taxon %<>% mutate(language = "en")
```

### license

```{r}
taxon %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "INBO")

```

### accessRights

```{r}
taxon %<>% mutate(accessRights = "http://www.inbo.be/en/norms-for-data-use")
```

### bibliographicCitation

This checklist is a compilation of three published volumes of the `Catalogue des Uredinales de Belgique (The rust fungi of Belgium)`. Information on the volumes is contained in `raw_part`. We will complement the volume number with the full reference (given in the metadata). For this, we create the matrix `full_reference`:

```{r, echo = F}
(full_reference <- as.data.frame(matrix(
  c("1", "Vanderweyen, A., & Fraiture, A. (2009). Catalogue des Uredinales de Belgique, 1re partie, Chaconiaceae, Coleosporiaceae, Cronartiaceae, Melampsoraceae, Phragmidiaceae, Pucciniastraceae, Raveneliaceae et Uropyxidaceae. Lejeunia, Revue de Botanique.",
    "2", "Vanderweyen, A., & Fraiture, A. (2009). Catalogue des Uredinales de Belgique, 2ème partie, Pucciniaceae (sauf Puccinia)(suite 2). Lejeunia, Revue de Botanique.",
    "3", "Vanderweyen, A., & Fraiture, A. (2012). Catalogue des Uredinales de Belgique, 3ème partie, Pucciniaceae (genre Puccinia). Lejeunia, Revue de Botanique."), 
  nrow = 3, 
  ncol = 2, 
  byrow = T,
  dimnames = list (c(1:3), c("raw_part", "full_reference")))))
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "Checklist of the rust fungi of Belgium")
```

### taxonID
### scientificName
### kingdom
### family
### taxonRank
### nomenclaturalCode
